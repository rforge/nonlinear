Cr=c()
slope=0
crcounter=1
DataExp = BuildTakens(Data, m = m, tau = tau)
numelem = nrow(DataExp)
auxDistance=matrix(0,numelem,numelem)
auxDistance[row(auxDistance)>col(auxDistance)]=dist(DataExp, method= meth)
#faltaria hacer comprobaciones acerca de t
mutualDistance=auxDistance[(col(auxDistance)+t)<=row(auxDistance)]
denom=(numelem-t)*(numelem-t+1)/2#denom=length(mutualDistance)
for (i in r){
cr_aux=length(mutualDistance[mutualDistance <= i ])/denom
if (cr_aux==0){
warning("Cr = 0 for r=",i,"! Omitting Cr for r<=",i,"\n")
minr_pos=crcounter-1
break
}else{
Cr[crcounter]=cr_aux
crcounter=crcounter+1
}
}
if (minr_pos>0){
lr=lr[1:minr_pos]
r=r[1:minr_pos]
lCr=log10(Cr)
interp=lm(lCr~lr)
slope=interp$coefficients[[2]]
if (plo){
plot(lr,lCr,'b')
lines(lr,interp$fitted.values,col='red')
}
}else{
r=c()
warning("Cr=0 for every r! Returning empty vectors\n")
}
return(list(r=r,Cr=Cr,dim=slope))
}
getAllDistances=function(DataExp,meth,t){
nElem=nrow(DataExp)
lastElemToCompute=nElem-t
distances=c()
for (i in 1:lastElemToCompute){
distances=c(getDistance(DataExp[i,],as.matrix(DataExp[(i+t):nElem,]),meth),distances)
}
return (distances)
}
getDistance=function(referenceVector,otherVectors,meth){
distances=c()
nElem=nrow(otherVectors)
if (is.null(nElem)){## just one vector
distances[[1]]=dist(rbind(referenceVector,otherVectors),method=meth)
}else{
for (i in 1:nElem){
distances[[i]]=dist(rbind(referenceVector,otherVectors[i,]),method=meth)
}
}
return(distances)
}
recurrencePlot=function(Data, m, tau,r,lmin=2,plo=FALSE,tit=""){
DataExp = BuildTakens( Data, m = m, tau = tau)
mutualDistance=as.matrix(dist(DataExp, method = "maximum"))
mutualDistance=(mutualDistance<r)
cp = c("#FFFFFF","#000000")
if (plo){
filled.contour(mutualDistance,col=cp,nlevels=2,plot.title=title(tit))
}
##
REC=sum(mutualDistance)/nrow(mutualDistance)^2
dp=calculateDiagonalParameters(mutualDistance,lmin)
return(c(list(REC=REC),dp))
}
calculateDiagonalParameters=function(distance,lmin=2){
l=nrow(distance)
Pl=rep(0,l-1)
for (i  in 2:(l-lmin+1)){
diagonal=diag(distance[1:(l-i+1),i:l])
Pl=updatePl(diagonal,Pl,lmin)
}
#The matrix is symmetric. Also, we must add the principal diagonal
Pl=c(2*Pl,1)
#begin parameter computations
num=sum((lmin:l)*Pl[lmin:l])
DET=num/sum(distance)
L=num/sum(Pl[lmin:l])
#pick the penultimate
Lmax=tail(which(Pl>0),2)[1]
DIV=1/Lmax
pl=Pl/sum(Pl)
diff_0=which(pl>0)
ENTR=-sum(pl[diff_0]*log(pl[diff_0]));
#results
params=list(DET=DET,DIV=DIV,L=L,ENTR=ENTR)
return(params)
}
updatePl=function(data,Pl,lmin){
pos=1
l=length(data)
while (pos<l){
actual_length=0
while( (data[[pos]]) && (pos<l)){
actual_length=actual_length+1
pos=pos+1
}
if (actual_length>=lmin){
Pl[actual_length]=Pl[actual_length]+1
}
pos=pos+1
}
return(Pl)
}
###########################   ApEn  #############################################################
approximateEntropy = function(data, m = 2, tau = 1, r = 0.2, N = NULL)
{
npoints = length(data)
if (is.null(N)) N=npoints
if (npoints > N) {
DataInt = data[(npoints/2 - N/2):(npoints/2 + N/2)]
}
else {
DataInt = data
}
r = r * sd(DataInt)
Phi1 = myAvgIntegralCorrelation( DataInt, m = m, tau = tau, r = r)
Phi2 = myAvgIntegralCorrelation( DataInt, m = (m + 1), tau = tau, r = r)
ApEn = Phi1 - Phi2
return(ApEn)
}
myAvgIntegralCorrelation = function (Data, m, tau, r)
{
Cmr = myIntegralCorrelation(Data, m = m, tau = tau, r = r)
Phi = sum(log(Cmr))/length(Cmr)
return(Phi)
}
myIntegralCorrelation=function (Data, m, tau, r)
{
DataExp = BuildTakens(Data, m = m, tau = tau)
numelem = nrow(DataExp)
mutualDistance = as.matrix(dist(DataExp, method = "maximum"))
Cmr = array(1:numelem)
for (i in 1:numelem) {
iDistance = mutualDistance[i, 1:numelem]
Cmr[i] = length(iDistance[iDistance <= r])/numelem
}
return(Cmr)
}
########################### Determining embedding dimension ####################
#Based on the article: "Practical method for determining the minimum embedding dimension
#of a scalar time series", By Liangyue Cao
#this function estimates the minimum embedding dimension for timeSeries.
#N is the number of points to be used.
#tau is the delay lag.
#maxDim is the maximum embedding dimension to be computed.
#distanceMethod defines the distance metric to be used.
#threshold specifies the limit value for E1(d) to consider d as the minimum embedding dimension
minimumEmbeddingDimension=function(timeSeries,N=length(timeSeries),tau,maxDim=15,distanceMethod="maximum",threshold=0.95,plo=TRUE){
#auxiliar variables
l=length(timeSeries)
data=timeSeries[(l/2-N/2+1):(l/2+N/2)]
embeddingDim=0 #if no d verifies E1(d)>=threshold, then we shall return 0
#First iteration: get E1(1) and E2(1)
Es1=getE(data,1,tau,distanceMethod)
Es2=getE(data,2,tau,distanceMethod)
Ed=c(Es1$E,Es2$E)
Ed_=c(Es1$E_,Es2$E_)
E1=c(Ed[[2]]/Ed[[1]])
E2=c(Ed_[[2]]/Ed_[[1]])
# compute from d=3 to d=maxDim
for (dimension in 3:maxDim){
#compute Ed,E1 and E2
Es=getE(data,dimension,tau,distanceMethod)
Ed[[dimension]]=Es$E
Ed_[[dimension]]=Es$E_
E1[[dimension-1]] = Ed[[dimension]]/Ed[[dimension-1]]
E2[[dimension-1]] = Ed_[[dimension]]/Ed_[[dimension-1]]
#compute if E1(d)>=threshold
if ((embeddingDim==0)&&(E1[[dimension-1]]>=threshold)){
embeddingDim=dimension-1
}
}
#plot graphics
if (plo){
plot(1:length(E1),E1,'b',main="computing the embedding dimension",xlab="dimension (d)",ylab="E1(d) & E2(d)",cex=0.1,ylim=c(0,max(E2)))
lines(1:length(E2),E2,'b',col=4,cex=0.1)
abline(h=c(1,threshold),col=2,lty=c(3,3))
legend("bottomright",col=c(1,4,2),lty=c(1,1,3),lwd=c(2.5,2.5,2.5),legend=c("E1(d)","E2(d)","limits for E1(d)"))
}
return (embeddingDim)
}
#auxiliar function to compute E, E1 and E2
getE=function(data,m,tau,distanceMethod="maximum"){
#construct takens vectors of dimensions m and m+1
takens=BuildTakens(data, m, tau)
takensPlusPlus=BuildTakens(data, m+1, tau)
#get distance in the m dimension to compute nearest neighbour
mutualDistance=as.matrix(dist(takens, method = distanceMethod))
mutualDistance[mutualDistance==0]=Inf
#number of iterations needed
maxIter=nrow(takensPlusPlus)
psi=c()
psi_=c()
#computing...
for (i in 1:maxIter){
#getClosest neighbour
neigh=as.numeric(which.min(mutualDistance[i,1:maxIter]))
num=as.numeric(dist(rbind(takensPlusPlus[i,],takensPlusPlus[neigh,]), method = distanceMethod))
psi[[i]]=num/mutualDistance[i,neigh]
psi_[[i]]=abs(data[[i+m*tau]]-data[[neigh+m*tau]])
}
return (list(E=mean(psi),E_=mean(psi_)))
}
#this function estimates the minimum embedding dimension for timeSeries.
#N is the number of points to be used.
#tau is the delay lag.
#maxDim is the maximum embedding dimension to be computed.
#distanceMethod defines the distance metric to be used.
#threshold specifies the limit value for E1(d) to consider d as the minimum embedding dimension
#theiler: the theiler window sets a "security distance" between takens vectors to avoid temporal correlations
#The theiler window is often estimated using a spaceTime plot
getEmbeddingDim=function(timeSeries,N=length(timeSeries),tau,maxDim=15,distanceMethod="maximum",threshold=0.95,plo=TRUE,theiler=1,title=""){
#auxiliar variables
l=length(timeSeries)
data=timeSeries[(l/2-N/2+1):(l/2+N/2)]
embeddingDim=0 #if no d verifies E1(d)>=threshold, then we shall return 0
#First iteration: get E1(1) and E2(1)
Es1=getETheiler(data,1,tau,distanceMethod,theiler)
Es2=getETheiler(data,2,tau,distanceMethod,theiler)
Ed=c(Es1$E,Es2$E)
Ed_=c(Es1$E_,Es2$E_)
E1=c(Ed[[2]]/Ed[[1]])
E2=c(Ed_[[2]]/Ed_[[1]])
# compute from d=3 to d=maxDim
for (dimension in 3:maxDim){
#compute Ed,E1 and E2
Es=getETheiler(data,dimension,tau,distanceMethod,theiler)
Ed[[dimension]]=Es$E
Ed_[[dimension]]=Es$E_
E1[[dimension-1]] = Ed[[dimension]]/Ed[[dimension-1]]
E2[[dimension-1]] = Ed_[[dimension]]/Ed_[[dimension-1]]
#compute if E1(d)>=threshold
if ((embeddingDim==0)&&(E1[[dimension-1]]>=threshold)){
embeddingDim=dimension-1
}
}
#plot graphics
if (plo){
plot(1:length(E1),E1,'b',main=paste(sep="\n","computing the embedding dimension",title),xlab="dimension (d)",ylab="E1(d) & E2(d)",cex=0.1,ylim=c(0,max(E2)))
lines(1:length(E2),E2,'b',col=4,cex=0.1)
abline(h=c(1,threshold),col=2,lty=c(3,3))
legend("bottomright",col=c(1,4,2),lty=c(1,1,3),lwd=c(2.5,2.5,2.5),legend=c("E1(d)","E2(d)","limits for E1(d)"))
}
return (embeddingDim)
}
#auxiliar function to compute E, E1 and E2
getETheiler=function(data,m,tau,distanceMethod="maximum",t=1){
if ((t<1)||(t>length(data))) error("invalid theiler window\n")
#construct takens vectors of dimensions m and m+1
takens=BuildTakens(data, m, tau)
takensPlusPlus=BuildTakens(data, m+1, tau)
#get distance in the m dimension to compute nearest neighbour
mutualDistance=as.matrix(dist(takens, method = distanceMethod))
#number of iterations needed
maxIter=nrow(takensPlusPlus)
psi=c()
psi_=c()
#computing...
for (i in 1:maxIter){
#getClosest neighbour
if ((i-t)<1) left_index=c() else left_index=1:(i-t)
if ((i+t)>maxIter) right_index=c() else right_index=(i+t):maxIter
auxDistances=mutualDistance[i,1:maxIter]
auxDistances[-c(left_index,right_index)]=Inf
neigh=as.numeric(which.min(auxDistances))
num=as.numeric(dist(rbind(takensPlusPlus[i,],takensPlusPlus[neigh,]), method = distanceMethod))
psi[[i]]=num/mutualDistance[i,neigh]
psi_[[i]]=abs(data[[i+m*tau]]-data[[neigh+m*tau]])
}
return (list(E=mean(psi),E_=mean(psi_)))
}
################################################################################
#################################################################################
################################################ Estimating tau
getEmbeddingLag=function(data,plo=FALSE){
autoCorrStructure = acf(data,type="correlation",lag.max=120,plot=plo)
#remember that positions start in 1!! Must substract 1
lag=head(which(abs(autoCorrStructure$acf)<=1/exp(1)),1)
if (length(lag)>0){
lag=lag-1
}else{
warning("It could not be find a propper embedding lag!, returning lag=0\n")
lag=0
}
return (lag)
}
รง
RTisean::d2                              Dimension and entropy estimation
?RTisean::d2
?tseriesChaos::d2
tseriesChaos::d2
fNonlinear::.d2
fNonlinear::.C2
nrow
acf
nrow(matrix(0,2,2))
nrow(matrix(0,3,2))
ncol(matrix(0,3,2))
library(help=tcltk)
qr(matrix(rnorm(100),sqrt(100)))
qr(matrix(1_4,2)
qr(matrix(1:44,2)
qr(matrix(1:4,2)
qr(matrix(1:4,2))
?rq
qr
?qr
?triangle
??triangle
matrix(1:4,2)
a=qr(matrix(1:4,2))
qr.r(qr)
qr.r(a)
qr.R(a)
qr.Q(a)%*%qr.R(a)
qr.Q(a)
??covariance
cov(1:2,4:5)
y=matrix(byrow=TRUE,c(0,1,3,2)m2)
y=matrix(byrow=TRUE,c(0,1,3,2),2)
y
z=matrix(byrow=TRUE,c(1,1,1,2),2)
z
cov(z,z)
t(z)*z
size(matrix(0,2,2))
dim(matrix(0,2,2))
library(RHRV)
CreateHRVData
m= CreateHRVData
()
m= CreateHRVData()
m
names(m)
?CreateHRVData
m$Ext
m$Extsource("myplot.r")
library(RHRV)
###########################################################################
um=0
uM=0.0625
vm=0.0625
vM=0.125
lm=0.125
lM=0.250
hm=0.250
hM=2
siz = 32; shif = 1; sizes = 2048*4;
www="d8"
typ="wavelet"
fichero="/datos/constantinoantonio.garcia/Tesis/beats/moi.beats"
s_plot=FALSE
splot=c(FALSE,TRUE,TRUE,TRUE)
############################################################
md = CreateHRVData( )
md = LoadBeatAscii(md,fichero)
names(md)
LoadBeatAscii
?LoadBeatAscii
names(md)
names(md$Beat)
ames(md$Beat
names(md$Beat
md$Beat
md$Beat$Time
md = LoadBeatAscii(md,fichero)
md = CreateHRVData( )
md = LoadBeatAscii(md,fichero)
md
names(md=
)
names(md)
LoadBeatAscii
md = LoadBeatAscii(md,fichero)
ms
md
md = 2608*0.001
md
md = LoadBeatAscii(md,fichero)
md = LoadBeatAscii(md,fichero,scale=0.01)
md = CreateHRVData( )
md = LoadBeatAscii(md,fichero,scale=0.01)
md
md = LoadBeatAscii(md,fichero,scale=0.01,datetime="1/1/1900 0:0:0")
md
md
md = LoadBeatAscii(md,fichero,scale=0.01,datetime="1/1/1900 0:0:0")
names(md)
md$datetime
md = LoadBeatAscii(md,fichero,scale=0.01,datetime="1/1/1900 0:1233:0")
md = LoadBeatAscii(md,fichero,scale=0.01,datetime="1/1/1900 0:23:0")
names(md)
md$datetime
md = LoadBeatAscii(md,fichero,scale=0.01,datetime="1/1/1900")
md = LoadBeatAscii(md,fichero,scale=0.01,datetime="1/1/1900 00:00:00")
md = BuildNIHR(md)
md = InterpolateNIHR (md)
md = CreateHRVData( )
md = LoadBeatAscii(md,fichero)
md = BuildNIHR(md)
md = InterpolateNIHR (md)
md = CreateHRVData( )
md = LoadBeatAscii(md,fichero)
md = BuildNIHR(md)
md = BuildNIHR
?BuildNIHR
?InterpolateNIHR
InterpolateNIHR
?approx
x=1:100
y=cos(x)
plot(x,y)
plot(x,y,'l')
aa=approxfun(x)
?approxfun
aa=approxfun(x,y,xout=seq(1,100,len=1000))
aa=approxfun(x,y,xout=seq(1,100,len=1000)
)
f=approxfun(x,y)
newy=approxfun(seq(1,100,len=10000))
newx=seq(1,100,len=10000)
plot(newx,newy)
newy
f
approxfun
x
y
f=approxfun(x,y)
f
f(seq(1,100,len=1000))
newx=seq(1,100,len=10000);newy=f(newx);plot(x,y);lines(newx,newy,col="red")
newx=seq(1,100,len=10000);newy=f(newx);plot(x,y);lines(newx,newy,col="red","b")
newx=seq(1,100,len=2000);newy=f(newx);plot(x,y);lines(newx,newy,col="red","b")
newx=seq(1,100,len=200);newy=f(newx);plot(x,y);lines(newx,newy,col="red","b")
ff=splinefun(x,y)
newx=seq(1,100,len=200);newy=ff(newx);plot(x,y);lines(newx,newy,col="red","b")
newx=seq(1,100,len=200);newy=f(newx);plot(x,y);lines(newx,newy,col="green","b")
newxs=seq(1,100,len=200);newys=ff(newxs);lines(newxs,newys,col="red","b")
?InterpolateNIHR
?splinefun
InterpolateNIHR
?CreateTimeAnalysis
library(RHRV)
?ReadFromFile
ReadFromFile
?dget
library(RHRV)
CreateTimeAnalysis
?CreateTimeAnalysis
quantile(rnorm(1000))
quantile(rnorm(1000))
?quantile
3**3
2**8
?"**"
?LoadApneaWFDB
x=rnorm()
x=rnorm(10000)
X=fft(x)
plot(abs(X))
plot(1:10000,abs(X),'l')
plot(x)
plot(abs(X))
plot(1:10000,abs(X),'l')
x=runif(10000)
plot(1:10000,abs(X),'l')
X=fft(x)
plot(1:10000,abs(X),'l')
X[1]=0
plot(1:10000,abs(X),'l')
setwd("~/Tesis/R/nonLinearFunctions/nonlinearAnalysis package/nonlinearAnalysis/R")
source("testPoincareMap.R")
source("testPoincareMap.R")
source("testPoincareMap.R")
source("testPoincareMap.R")
source("testPoincareMap.R")
source("testPoincareMap.R")
source("testPoincareMap.R")
source("testPoincareMap.R")
source("testPoincareMap.R")
rossler()
?plot3d
plot3d(r$x,r$y,r$z)
points3d(a[,1],a[,2],a[,3],col="red")
plot3d(r$x,r$y,r$z)
points3d(a[,1],a[,2],a[,3],col="red",cex=1)
?points3d
plot3d(r$x,r$y,r$z,size=0.0001)
points3d(a[,1],a[,2],a[,3],col="red")
source("testPoincareMap.R")
source("testPoincareMap.R")
source("testPoincareMap.R")
source("testPoincareMap.R")
source("testPoincareMap.R")
source("testPoincareMap.R")
(1-0.99)*4000
lorenz
source("testPoincareMap.R")
source("testPoincareMap.R")
rossler
source("testPoincareMap.R")
source("testPoincareMap.R")
source("testPoincareMap.R")
library(RHRV)
BuildNIHR
